<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Heilzeit</title>
  <link rel="stylesheet" href="styles/style.css">
<script src="scripts/main.js"></script>

(function() {
  const vfsBlobUrls = {"/data.json":"blob:https://otst-osw-studio.hf.space/57b9efcf-81ce-466d-9b10-3fa9386e3de6","/scripts/main.js":"blob:https://otst-osw-studio.hf.space/06c8f3f8-b2d7-4598-a618-7d88e86a4566","/images/profile.jpg":"blob:https://otst-osw-studio.hf.space/8f3991de-998b-4df4-855a-41bd1176e65f"};
  
  // Helper function to resolve VFS paths to blob URLs
  function resolveVfsUrl(url) {
    if (!url || typeof url !== 'string') return url;
    if (url.startsWith('/assets/') && vfsBlobUrls[url]) {
      return vfsBlobUrls[url];
    }
    return url;
  }
  
  // Intercept Image src setter to handle ALL image loading
  const originalSrcDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
  Object.defineProperty(HTMLImageElement.prototype, 'src', {
    get: function() {
      return originalSrcDescriptor.get.call(this);
    },
    set: function(value) {
      const resolvedUrl = resolveVfsUrl(value);
      return originalSrcDescriptor.set.call(this, resolvedUrl);
    },
    enumerable: true,
    configurable: true
  });
  
  // Intercept setAttribute for src attributes
  const originalSetAttribute = Element.prototype.setAttribute;
  Element.prototype.setAttribute = function(name, value) {
    if ((name === 'src' || name === 'href') && this instanceof HTMLImageElement) {
      value = resolveVfsUrl(value);
    }
    return originalSetAttribute.call(this, name, value);
  };
  
  // Intercept innerHTML to catch template-generated images
  const originalInnerHTMLDescriptor = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML');
  Object.defineProperty(Element.prototype, 'innerHTML', {
    get: function() {
      return originalInnerHTMLDescriptor.get.call(this);
    },
    set: function(value) {
      if (typeof value === 'string' && value.includes('/assets/')) {
        // Replace asset URLs in the HTML string before setting
        const srcRegex = new RegExp('src=["\']([^"\']*/assets/[^"\']*)["\']', 'g');
        value = value.replace(srcRegex, function(match, url) {
          const resolvedUrl = resolveVfsUrl(url);
          if (resolvedUrl !== url) {
            return match.replace(url, resolvedUrl);
          }
          return match;
        });
      }
      return originalInnerHTMLDescriptor.set.call(this, value);
    },
    enumerable: true,
    configurable: true
  });
  
  // Intercept Image constructor
  const OriginalImage = window.Image;
  window.Image = function(...args) {
    const img = new OriginalImage(...args);
    // Override src setter for this instance too
    const descriptor = Object.getOwnPropertyDescriptor(img, 'src') || 
                      Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
    if (descriptor) {
      Object.defineProperty(img, 'src', {
        get: descriptor.get,
        set: function(value) {
          const resolvedUrl = resolveVfsUrl(value);
          return originalSrcDescriptor.set.call(this, resolvedUrl);
        },
        enumerable: true,
        configurable: true
      });
    }
    return img;
  };
  // Preserve original Image properties
  Object.setPrototypeOf(window.Image, OriginalImage);
  window.Image.prototype = OriginalImage.prototype;
  
  // Intercept createElement for img elements
  const originalCreateElement = document.createElement;
  document.createElement = function(tagName, options) {
    const element = originalCreateElement.call(this, tagName, options);
    if (tagName.toLowerCase() === 'img') {
      const originalSrcDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
      Object.defineProperty(element, 'src', {
        get: function() {
          return originalSrcDescriptor.get.call(this);
        },
        set: function(value) {
          const resolvedUrl = resolveVfsUrl(value);
          return originalSrcDescriptor.set.call(this, resolvedUrl);
        },
        enumerable: true,
        configurable: true
      });
    }
    return element;
  };
  
  // Intercept fetch requests to VFS assets
  const originalFetch = window.fetch;
  window.fetch = function(input, init) {
    const url = typeof input === 'string' ? input : input.url;
    const resolvedUrl = resolveVfsUrl(url);
    
    if (resolvedUrl !== url) {
      return originalFetch(resolvedUrl, init);
    }
    
    return originalFetch(input, init);
  };
  
  // Intercept XMLHttpRequest for older code
  const OriginalXHR = window.XMLHttpRequest;
  window.XMLHttpRequest = function() {
    const xhr = new OriginalXHR();
    const originalOpen = xhr.open;
    
    xhr.open = function(method, url, ...args) {
      const resolvedUrl = resolveVfsUrl(url);
      return originalOpen.call(this, method, resolvedUrl, ...args);
    };
    
    return xhr;
  };
  
  // Process any existing images in the DOM when ready
  function processExistingImages() {
    const images = document.querySelectorAll('img[src*="/assets/"]');
    images.forEach(img => {
      const currentSrc = img.src;
      const resolvedSrc = resolveVfsUrl(currentSrc);
      if (resolvedSrc !== currentSrc) {
        img.src = resolvedSrc;
      }
    });
  }
  
  // Use MutationObserver to catch dynamically added images
  function setupMutationObserver() {
    if (typeof MutationObserver !== 'undefined') {
      const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          mutation.addedNodes.forEach(function(node) {
            if (node.nodeType === 1) { // Element node
              if (node.tagName === 'IMG' && node.src && node.src.includes('/assets/')) {
                const resolvedSrc = resolveVfsUrl(node.src);
                if (resolvedSrc !== node.src) {
                  node.src = resolvedSrc;
                }
              }
              // Also check children
              const childImages = node.querySelectorAll && node.querySelectorAll('img[src*="/assets/"]');
              if (childImages) {
                childImages.forEach(img => {
                  const resolvedSrc = resolveVfsUrl(img.src);
                  if (resolvedSrc !== img.src) {
                    img.src = resolvedSrc;
                  }
                });
              }
            }
          });
        });
      });
      
      observer.observe(document.body || document.documentElement, {
        childList: true,
        subtree: true
      });
    }
  }
  
  // Setup everything when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
      processExistingImages();
      setupMutationObserver();
    });
  } else {
    processExistingImages();
    setupMutationObserver();
  }
})();
</script>
</head>
<body>

  <div class="welcome-card">
    <img src="blob:https://otst-osw-studio.hf.space/8f3991de-998b-4df4-855a-41bd1176e65f" alt="Фото психолога" class="profile-photo">
  
    <h1>Психолог-проводник по внутренним лабиринтам</h1>
    <p>Онлайн-консультации. Глубинная работа с внутренними процессами и жизненными сценариями.</p>
  
    <a href="#contact" class="contact-link">Связаться</a>
  </div>

  <main>

    <section id="about" class="section">
      <h2>О себе</h2>
      <p>
        Я работаю как психолог-проводник, помогая исследовать внутренние
        состояния, конфликты и повторяющиеся жизненные сценарии.
      </p>
      <p>
        Обучение: Ассоциация глубинной психологии Теурунг™.<br>
        Программа «Архетипы Судьбы». Основы юнгианской психологии.
      </p>
    </section>

    <section id="services" class="section">
  <h2>Услуги</h2>
  <ul>
    <li>онлайн-консультации</li>
    <li>работа с внутренними конфликтами</li>
    <li>исследование жизненных сценариев</li>
    <li>поиск смысла и опоры</li>
  </ul>

  <p><strong>Стоимость:</strong> 10 € / час</p>
</section>

      <h2>Услуги</h2>
      <ul>
        <li>онлайн-консультации</li>
        <li>работа с внутренними конфликтами</li>
        <li>исследование жизненных сценариев</li>
        <li>поиск смысла и опоры</li>
      </ul>
    </section>

    <section id="contact" class="section">
      <h2>Контакты</h2>
      <p>
        Telegram: <strong>@hanna_tomak</strong><br>
        Email: <strong>htomachynska@gmail.com</strong>
      </p>
      <p class="note">
        Консультации не являются медицинской или психиатрической помощью.
      </p>
    </section>

  </main>

  <script src="blob:https://otst-osw-studio.hf.space/06c8f3f8-b2d7-4598-a618-7d88e86a4566"></script>
</body>
</html>
